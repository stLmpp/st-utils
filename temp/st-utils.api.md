## API Report File for "st-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ConditionalKeys } from 'type-fest';

// @public (undocumented)
export function arrayAt<T>(array: readonly T[], index: number): T | undefined;

// @public (undocumented)
export function arrayGroupBy<T extends Record<any, any> = Record<any, any>, K extends keyof T = keyof T>(array: readonly T[], key: K): GroupedTuple<T, K>;

// @public (undocumented)
export function arrayGroupBy<T extends Record<any, any> = Record<any, any>, K extends keyof T = keyof T>(array: readonly T[], key: K, returnType: 'tuple'): GroupedTuple<T, K>;

// @public (undocumented)
export function arrayGroupBy<T extends Record<any, any> = Record<any, any>, K extends keyof T = keyof T>(array: readonly T[], key: K, returnType: 'map'): GroupedMap<T, K>;

// @public (undocumented)
export function arrayGroupBy<T extends Record<any, any>, K extends ConditionalKeys<T, KeyType_2>>(array: readonly T[], key: K, returnType: 'object'): GroupedObject<T, K>;

// @public (undocumented)
export function arrayMin(array: readonly number[]): number;

// @public (undocumented)
export function arrayMinBy<T extends Record<any, any>, K extends ConditionalKeys<T, number>>(array: readonly T[], key: K): T;

// @public (undocumented)
export function arrayOrderBy<T, K extends keyof T>(values: readonly T[], keyOrCommand?: OrderByType<T>, order?: OrderByDirection): T[];

// @public (undocumented)
export function arrayRemove<T>(array: readonly T[], predicate: (element: T, index: number, array: T[] | readonly T[]) => boolean): T[];

// @public (undocumented)
export function arrayRemoveMutate<T>(array: T[], predicate: (element: T, index: number, array: T[]) => boolean): T[];

// @public (undocumented)
export function arrayRotate<T>(array: readonly T[], rotations: number): T[];

// @public (undocumented)
export function arraySample<T>(array: readonly T[]): T;

// @public (undocumented)
export function arraySearch<T, K extends keyof T>(array: readonly T[], keyOrKeysOrCallback: K | readonly K[] | ((item: T) => T[K]), _term: string | null | undefined): T[];

// @public (undocumented)
export function arraySum(array: readonly number[]): number;

// @public (undocumented)
export function arraySumBy<T extends Record<any, any>, K extends ConditionalKeys<T, number | null | undefined>>(array: readonly T[], key: K): number;

// @public (undocumented)
export function arrayUniq<T>(value: readonly T[]): T[];

// @public (undocumented)
export function arrayUniqBy<T extends Record<any, any>, K extends keyof T>(array: readonly T[], key: K | ((item: T) => T[K])): T[];

// @public (undocumented)
export function arrayUniqWith<T>(array: readonly T[], comparator: (valueA: T, valueB: T) => boolean): T[];

// @public
export class ArrayUtil<T extends Record<any, any>, K extends keyof T = keyof T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    constructor(array: readonly T[], idGetter: IdGetter<T, K>);
    append(item: T): this;
    at(index: number): T | undefined;
    // (undocumented)
    every(predicate: ArrayUtilPredicate<T>): boolean;
    // (undocumented)
    filter(predicate: ArrayUtilPredicate<T>): this;
    // (undocumented)
    find(predicate: ArrayUtilPredicate<T>): T | undefined;
    // (undocumented)
    findIndex(predicate: ArrayUtilPredicate<T>): number;
    // (undocumented)
    findLast(predicate: ArrayUtilPredicate<T>): T | undefined;
    // (undocumented)
    forEach(callback: ArrayUtilVoidCallback<T>): this;
    getFirst(): T | undefined;
    // (undocumented)
    getIndexOf(id: IdKeyType): number;
    getLast(): T | undefined;
    getLastIndex(): number;
    getMany(ids: IdKeyType[]): T[];
    getOne(id: IdKeyType): T | undefined;
    getOneOrFail(id: IdKeyType): T;
    // (undocumented)
    has(id: IdKeyType): boolean;
    insert(item: T | readonly T[], index: number): this;
    // (undocumented)
    map(callback: ArrayUtilUpdate<T>): this;
    // (undocumented)
    move(fromIndex: number, toIndex: number): this;
    orderBy(order?: OrderByType<T>, direction?: OrderByDirection): this;
    prepend(item: T): this;
    remove(idOrPredicate: IdKeyType | IdKeyType[] | ArrayUtilPredicate<T>): this;
    removeByIndex(index: number | number[]): this;
    // (undocumented)
    reverse(): this;
    // (undocumented)
    rotate(rotations: number): this;
    sample(): T | undefined;
    // (undocumented)
    slice(start?: number, end?: number): this;
    // (undocumented)
    some(predicate: ArrayUtilPredicate<T>): boolean;
    // (undocumented)
    toArray(): T[];
    // (undocumented)
    toMap(): Map<IdKeyType, T>;
    // (undocumented)
    toObject(): Record<IdKeyType, T>;
    // (undocumented)
    toSet(): Set<T>;
    // (undocumented)
    uniq(): this;
    // (undocumented)
    uniqBy(key: keyof T): this;
    // (undocumented)
    uniqWith(comparator: (valueA: T, valueB: T) => boolean): this;
    update(idOrPredicate: IdKeyType | IdKeyType[] | ArrayUtilPredicate<T>, partialOrCallback: T | Partial<T> | ArrayUtilUpdate<T>): this;
    upsert(idOrItems: IdKeyType | (T | Partial<T>)[], partial?: T | Partial<T> | ((entity: T | undefined) => T)): this;
}

// @public (undocumented)
export function arrayUtil<T extends {
    id: number;
}, K extends keyof T>(array: readonly T[]): ArrayUtil<T, K>;

// @public (undocumented)
export function arrayUtil<T extends Record<any, any>, K extends keyof T>(array: readonly T[], idGetter: IdGetter<T, K>): ArrayUtil<T, K>;

// @public (undocumented)
export type ArrayUtilPredicate<T extends Record<any, any>> = (entity: T, index: number, array: readonly T[]) => boolean;

// @public (undocumented)
export type ArrayUtilUpdate<T extends Record<any, any>> = (entity: T, index: number, array: readonly T[]) => T;

// @public (undocumented)
export type ArrayUtilVoidCallback<T extends Record<any, any>> = (entity: T, index: number, array: readonly T[]) => void;

// @public (undocumented)
export type BooleanInput = string | boolean | null | undefined;

// @public (undocumented)
export function coerceArray<T>(value: T | readonly T[]): T[];

// @public (undocumented)
export function coerceBooleanProperty(value: BooleanInput): boolean;

// @public (undocumented)
export function coerceNumberProperty(value: NumberInput, fallback?: number): number;

// @public (undocumented)
export function getFirstKey<T extends Record<any, any>>(object: T): keyof T | undefined;

// @public (undocumented)
export type GroupedMap<T extends Record<any, any> = Record<any, any>, K extends keyof T = keyof T> = Map<T[K], T[]>;

// @public (undocumented)
export type GroupedObject<T extends Record<any, any>, K extends ConditionalKeys<T, KeyType_2>> = Record<T[K], T[]>;

// @public (undocumented)
export type GroupedReturnType = 'tuple' | 'map' | 'object';

// @public (undocumented)
export type GroupedTuple<T extends Record<any, any> = Record<any, any>, K extends keyof T = keyof T> = [T[K], T[]][];

// @public (undocumented)
export type IdGetter<T extends Record<any, any>, K extends keyof T> = K | IdGetterFn<T>;

// @public (undocumented)
export type IdGetterFn<T extends Record<any, any>> = (entity: T) => IdKeyType;

// @public (undocumented)
export type IdKeyType = number | string;

// @public (undocumented)
export function isArray(value: any): value is any[] | readonly any[];

// @public (undocumented)
export function isBoolean(value: any): value is boolean;

// @public (undocumented)
export function isDate(value: any): value is Date;

// @public (undocumented)
export function isFunction(value: any): value is (...args: any[]) => any;

// @public (undocumented)
export function isIterable<T>(value: any): value is Iterable<T>;

// @public (undocumented)
export function isKeyof<T, K extends keyof T>(value: any): value is K;

// @public (undocumented)
export function isMap(value: any): value is Map<any, any>;

// @public (undocumented)
export function isNil(value: any): value is null | undefined;

// @public (undocumented)
export function isNotNil<T>(value: T): value is NonNullable<T>;

// @public (undocumented)
export function isNull(value: any): value is null;

// @public (undocumented)
export function isNumber(value: any): value is number;

// @public (undocumented)
export function isObject(value: any): value is Record<any, any>;

// @public (undocumented)
export function isObjectEmpty(value: Record<any, any>): boolean;

// @public (undocumented)
export function isObjectEqualShallow<T extends Record<any, any>>(objectA: T | null | undefined, objectB: T | null | undefined): boolean;

// @public (undocumented)
export function isPlainObject(value: any): value is Record<string | number | symbol, any>;

// @public (undocumented)
export function isRegExp(value: any): value is RegExp;

// @public (undocumented)
export function isSet(value: any): value is Set<any>;

// @public (undocumented)
export function isString(value: any): value is string;

// @public (undocumented)
export function isSymbol(value: any): value is symbol;

// @public (undocumented)
export function isUndefined(value: any): value is undefined;

// @public (undocumented)
export function iterableMax(iterable: Iterable<number> | null | undefined): number;

// @public (undocumented)
export function iterableMaxBy(iterable: null | undefined, callback: any): null;

// @public (undocumented)
export function iterableMaxBy<T>(iterable: Iterable<T> | null | undefined, callback: (item: T) => number | null | undefined): T | null;

// @public (undocumented)
type KeyType_2 = string | number | symbol;
export { KeyType_2 as KeyType }

// @public (undocumented)
export function noop(): void;

// @public (undocumented)
export function normalizeString(str: any): string;

// @public (undocumented)
export type NumberInput = string | number | null | undefined;

// @public (undocumented)
export type OrderByDirection = 'asc' | 'desc';

// @public (undocumented)
export type OrderByType<T, K extends keyof T = keyof T> = K | ((value: T) => any) | (((value: T) => any) | K)[] | Partial<Record<K, OrderByDirection>>;

// @public
export function parseIdGetter<T extends Record<any, any>, K extends keyof T>(getter: IdGetter<T, K>): IdGetterFn<T>;

// @public (undocumented)
export function random(min: number, max: number): number;

// @public (undocumented)
export function round(number: number, decimals?: number): number;

// (No @packageDocumentation comment for this package)

```
